---
layout:     post
title:      "PHP数组函数讲解   「转」"
subtitle:   "PHP array functions  "
date:       2014-3-24
author:     "LingDie | 靈蝶"
header-img: "img/blog/2014/shuzu.jpg"
tags:
    - PHP
    - 数组
    - 函数
    - 转载
---

### 1.键名变成大写或者小写：

array_change_key_case($arr,CASE_UPPER/CASE_LOWER);

upper就代表转成大写，lower就代表转成小写
其实数组的键名是分大小写的，如果说，转换之后有的键重复了，那么前面的键名会被后面的覆盖。


### 2.分割数组：

array_chunk($arr,数量,true/false)，

把数组按个数分，每组xxx个元素分割，把原数组的元素分配到小组中，如果元素组不够平均分摊，那么确保能平均分的平均分，剩下的可以缺；最后一项为真，那么保留原数组的键名，假的话就不保留，形成一个新数组


### 3.合并数组：

（1）将两个数组的值，一个作为新数组的键名，一个作为数组的键值，组合成新数组：
array_combine($arr1,$arr2);
$arr1的值，形成新数组的键，$arr2的值，形成新数组的值。注意：$arr1和$arr2的个数必须一致，否则报错。


（2）将多个数组捏成一个数组：
array_merge($arr1,$arr2,$arr3....);
多个数组的时候，如果原来的键名不是整形，那么会保留下来，如有冲突，则最后的元素会覆盖其他元素；如果原来的键值有整形，那么新数组会把所有整形的键名打破，重新从0开始排。
一个数组的时候，如果里面没有整形，那么新数组和元素组一样；如果有整形，那么把键名打碎重组。
array_merge对于键名冲突的情况，采取的是覆盖的策略。


（3）array_merge_recursive($arr1,$arr2,$arr3....);
与array_merge唯一不同的地方就是，他对于冲突的键名，采取的办法是，将所有键名相同的值，归拢成一个数组，而且里面的键名从0开始定义，保留每一个值。recursive是递归的意思。



### 4.求差值：


（1）比较几个数组之间的值，返回他们的差值:
array_diff($arr1,$arr2,$arr3....);
这个差值代表：先比较$arr1和$arr2，从$arr1中删去$arr2中和$arr1相同的值的部分；再比较$arr1和$arr3，同样的从$arr1删去相同的部分；以此类推，形成新的数组，键和值都是没有被删去的，原样保留。


（2）比较几个数组之间的值，返回他们的差值（使用自定义函数比较键名）：
array_udiff($arr1,$arr2,$arr3....,'functionname');


（3）比较几个数组之间的键，返回他们的差值：
array_diff_key($arr1,$arr2,$arr3....);
与array_diff()类似，但是比较的是值。


（4）比较几个数组之间的键和值，返回他们的差值：
array_diff_assoc($arr1,$arr2,$arr3....);
这个要比较键和值，两个数组的键和值都相同时才可以删去。


（5）比较几个数组之间的键和值，返回他们的差值（使用自定义函数比较键名）：
array_diff_uassoc($arr1,$arr2,$arr3....,'functionname');
比较键和值，使用用户自定义的函数来求差值


（6）比较几个数组之间的键和值，返回他们的差值（使用内建函数比较键名，使用自定义函数比较键值）：
array_udiff_assoc($arr1,$arr2,$arr3....,'functionname');


（7）比较几个数组之间的键和值，返回他们的差值（使用自定义函数比较键名和键值）：
array_udiff_uassoc($arr1,$arr2,$arr3....,'functionname1','functionname2');


### 5.填充
（1）创建一个数组，用一个值来填充：
$arr = array_fill(索引起始，值的个数，值);
索引起始只能是数字，但是可以是小数、负数，值的个数必须是正数。最后形成的数组，所有的值都是一样的。


（2）创建一个数组，用一个数组作为键名，一个值作为键值来填充：
$arr = array_fill_key($arr,'值');
新数组的键名是原来$arr中的值，值都是新设定的值，而且都是一样的。


（3）将一定数量的特定值填充进已知数组：
$newarr = array_pad($arr,个数，插入的值);
其中那个个数代表了插入之后新数组的个数，这个值可以是浮点型，他会自动转换成整形，当他是正的时候，代表从后面插入新的值；当他是负的时候，代表他从前面插入新的值；当这个值小于原数组本身元素的个数的时候，填充失败，没什么变化。


### 6.用回调函数过滤数组中的元素：

array_filter($arr,callbackfunciton);
filter是过滤的意思。




### 7.求交集：

（1）比较几个数组之间的键值，求交集：
array_intersect($arr1,$arr2,$arr3...);
inersect是交叉的意思。这个要根据值来比较，首先把$arr1和$arr2比较，求交集，删去不相交的部分，形成的数组，再和$arr3来比较...


（2）比较几个数组之间的键值，求交集（使用用户自定义函数）：
array_uintersect($arr1,$arr2,$arr3....,'functionname');


（2）比较几个数组之间的键名，求交集：
array_intersect_key($arr1,$arr2,$arr3...);


（3）比较几个数组之间的键名，求交集（用自定义函数）：
array_intersect_ukey($arr1,$arr2,$arr3....functionname);


（4）比较几个数组之间键名和键值，求交集：
array_intersect_assoc($arr1,$arr2,$arr3...);
键名和值都相同才能被保留下来，这个系列与array_diff系列的正好相反


（5）比较几个数组之间键名和键值，求交集（用自定义函数）：
array_intersect_uassoc($arr1,$arr2,$arr3....functionname);


（6）比较几个数组之间键名和键值，求交集（用内建函数比较键名，用自定义函数比较键值）：
array_uintersect_assoc($arr1,$arr2,$arr3....functionname);


（7）比较几个数组之间键名和键值，求交集（使用自定义函数比较键名和键值）：
array_uintersect_uassoc($arr1,$arr2,$arr3....,'functionname1','functionname2');


### 7.搜索：

（1）array_key_exists('键名',$arr);
返回的是真或假


（2）再数组中搜索某个键值，并返回对应的键名：
$keyname = array_search('键值',$arr,true/false/不写);//in_array()和他是一样的，所以in_array()就不写出来了
当true时，相当于===，类型和数据必须都相等的时候才返回。如果没有，那就返回false。


### 8.数组属性：

（1）返回数组的键名：
$keyarr = array_keys($arr,'值名',true);如果指定了第二个参数，那么就要按照键值名来寻找这个键名，返回去；第三个参数默认为false，为true时，相当于===


（2）返回数组的键值：
$valuearr = array_values($arr);

返回键值，形成新数组，键名重组



（3）随机返回的数组的一个键名：
$random_keyarr = array_rand($arr,'键名的个数');
没啥说的，就是返回数组中随机的几个键名而已，返回的是键名所构成的数组，如果就个数是1的话，那就返回的是一个字符串或者整形（就是那个键）。


（4）返回数组的元素的个数：
$numbers = count($arr,0或者1);//sizeof($arr)也可以，sizeof是他的别名

默认是0，不开启递归模式；1的时候开启


（5）返回多维数组某一个索引的全部值：
array_column($arr,'索引名字','不用写或者写索引名字');
最后一个要是写的话，那么新数组的索引就是按照其多维数组里面的数组的其他索引名字，比如说要取的是name，然后最后的参数是id，那么新数组索引就是原来的id


（6）统计一个数组中的值出现的个数，就像是画正字，返回一个新的数组：
array_count_values($arr);
返回的这个数组的键，是原来数组的值，值就是出现的个数。


### 9.从一个或者多个数组里取值，再用函数处理，处理后形成一个新的数组：

$newarr = array_map('函数的名字',$arr1,$arr2,$arr3....);//函数名要用单引号扩上，不用加()
function name($v1,$v2,$v3...){
有几个数组输入就处理几个输入的数组的参数
return $result;
}
处理完之后，形成一个新的数组


### 10.排序：

（1）将索引数组每一项升序排列保存：
sort($arr,参数(可以不写));
注意，他不是以arr_开头的，第二个参数一共有五种：
①SORT_REGULAR，0，默认项，常规排序，按照ASCII排序，不改变类型。
②SORT_NEMERIC，1，把每一项作为数字来处理
③SORT_STRING，2，把每一项作为字符串来处理
④SORT_LOCALE_STRING，3，把每一项作为字符串来处理，基于当前区域设置（可通过setlocale()进行更改）
⑤SORT_NATURAL，4，把每一项作为字符串来处理，使用类似natsort()的自然排序
⑥SORT_FLAG_CASE，5，可以结合（按位或）SORT_STRING或SORT_NATURAL对字符串进行排序，不区分大小写
按照ASCII排序的，所以数字在前，其次大写字母，最后小写字母，执行后若成功返回ture，失败返回false。原数组被改变。


（2）将索引数组每一项降序排列保存：
rsort($arr,参数(可以不写));


（3）将索引数组每一项排列保存（使用自定义函数）：
usort($arr,"functioname");


（4）将关联数组每一项升序排列保存：
asort($arr,参数(可以不写));
这个和sort的区别是处理后的索引依然保留，比较针对关联数组。


（5）将关联数组每一项降序排列保存：
arsort($arr,参数(可以不写));


（6）将关联数组每一项排列保存（使用自定义函数）：
uasort($arr,"functioname");


（7）将数组按照键名升序排列保存：
ksort($arr,参数(可以不写));


（8）将数组按照键名降序排列保存：
krsort($arr,参数(可以不写));


（9）将数组按照键名排列保存（使用自定义函数）：
uksort($arr,"functioname");


（10）将多个数组进行排序：
array_multisort($arr1,顺序类型,排序类型,$arr2,顺序类型,排序类型……);
这个更强大一些，可以对多个数组进行非一般的操作，其中顺序类型有两种：SORT_ASC（默认，可不写）和SORT_DESC，他们是ascend和descend。排序类型和sort()相同，如果不设置这些参数可以直接写数组名


（11）采用“自然排序”算法对数组进行排序：
natsort($arr);
保留原有索引


（12）采用不区分大小写的“自然排序”算法对数组进行排序：
natcasesort($arr);

保留原有索引


（13）随机打乱数组的元素的顺序：
shuffle($arr);


### 11.对数组的操作：

（1）将数组的值和键反转：

array_flip($arr);

这个没啥说的，挺有意思的。

（2）调换数组顺序：

$newarr = array_reverse($arr,true/false（默认）/不写);

把一个数组的元素的顺序反过来，但是数组里面的数组，就是多层的不能反转。true代表保留原数组的键名，false不保留。


（3）删除数组中重复的部分：
$newarr = array_unique($arr);
若有好几个重复的值，那么保留第一个，去除剩下的

（4）删除数组最后一个元素，并返回这个元素的值：
array_pop($arr);


（5）删除数组第一个元素，并返回这个元素的值：
$value = array_shift($arr);


（6）向数组尾部插入多个元素：
$newArrayLength = array_push($arr,'值1','值2','值3'……);
这个相当于$arr[]='值1';这个操作，所以当用array_push插入一个值的时候，还不如用$arr[]='值1';这种形式效率高。
插入后的元素的键都是数字键。


（7）向数组头部插入多个元素：
$newArrayLength = array_ushift($arr,'值1','值2','值3'……);

插入后，原数组的数字键名将打破重组。


（8）反转数组：
$newarr = array_reverse($arr,true/false（默认）/不写);
把一个数组的元素的顺序反过来，但是数组里面的数组，就是多层的不能反转。true代表保留原数组的键名，false不保留。


### 12.计算：

（1）返回数组的乘积：
$product = array_product($arr);
product是乘积的意思。有字符串的结果都为0。可以有负数，也可以有浮点型。空数组的乘积返回1（PHP5.3.6起）


（2）返回数组中的和：
array_sum($arr);
返回数组中所有值的和。





### 13.向用户自定义函数发送数组中的值，并返回一个字符串：

$string = array_reduce($arr,functionname,'发送到函数的初始值（可以没有）');
这就是取数组中的值，处理，返回形成一个字符串。


### 14.代替：

（1）将后面数组的值替换前面数组的值，这个要根据键来判断是否替代的：
$newarr = array_replace($arr1,$arr2,$arr3....);
如果$arr1中键与$arr2中的键有相同的部分，那么相同的部分被代替，不相同的键$arr1的原样保留，$arr2的创建。
$arr1的和$arr2的对比代替完之后，他们的结果再与$arr3对比代替，以此类推。


（2）递归代替：
$newarr = array_replace_recursive($arr1,$arr2,$arr3....);
recursive是递归的意思。这个补充了array_replace()的局限，当被代替的数组中包含数组的时候，也就是数组下面还有数组，要实现最里层数组的替换功能，就要用到递归替换。





### 15.切开数组：

（1）将按照指定位置和长度切开数组：
$newarr = array_slice($arr,起始位置，长度，true/false/不写);
当起始位置为0时，代表从初始切，第一位切进去，如果是2，那就在第2位和第3位中间开始切，第3位切进去；如果是个小数，采取进一法；如果是个负数，代表从后面往前切，比如说-1，就是把倒数第一个切进去。
当长度是个正数的时候，代表切开的长度；当他是负数的时候，代表切到哪里，比如说，-2，代表切到倒数第二项。
最后一个true和false代表是否保留原有键名，默认是不保留，他只针对整型键名。
slice是切的意思


### 16.从数组中移除元素，并用新元素取代他：

array_splice($arr1,起始位置,长度，$arr2);
与arrary_slice()类似，长度代表从$arr1移除的长度，$arr2可以不写，不写的时候就相当于移除的作用了。





### 17.对数组的每一个元素使用自定义函数处理：

（1）array_walk($arr,'functionname');


（2）array_walk_recursive($arr,'functionname');
可以对数组中的数组操作，递归




### 18.数组游标：

（1）返回数组当前元素：
current($arr);//pos($arr)也可以，pos是他的别名


（2）返回数组当前元素的键名：
key($arr);


（3）向下移动数组的指针：
next($arr);


（4）向上移动数组的指针：
prev($arr);


（5）将数组的指针移至最后：
end($arr);


（6）将数组的指针移至开头：
reset($arr);


（7）返回当前元素的键名和键值，并且将指针向下移动：
$array = each($arr);
返回的数组中包括的四个元素：键名为0，1，key和value。单元0和key是键名，1和value是数据


（8）把数组的元素依次赋予变量：
list($a1,$a2,$a3……) = $arr;
注意：只能赋予$arr中的整形索引，非整形的会赋给NULL，出NOTICE提示；赋值的时候是倒序的，先赋给左侧最后一个变量



### 19.创建：

（1）创建一个包含变量名和他们值的数组：
$arr = compact($var1,$var2,$var3……);


（2）以数组的索引为变量名，以键值为变量值，从数组中依次创建变量：
extract($arr);
返回的是成功创建的变量数目。这个与compact()正好相反。


（3）创建一个数组，指定他的最小值和最大值：
$arr = range(最小值,最大值,步长);
步长不写的话默认是1

